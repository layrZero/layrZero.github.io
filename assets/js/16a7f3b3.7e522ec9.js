"use strict";(self.webpackChunkscaffold=self.webpackChunkscaffold||[]).push([[8186],{3423:(n,t,e)=>{e.r(t),e.d(t,{assets:()=>a,contentTitle:()=>r,default:()=>p,frontMatter:()=>s,metadata:()=>o,toc:()=>d});const o=JSON.parse('{"id":"trading-platform/tradingview/futures-to-options-module","title":"Futures to Options Module","description":"The \\"Futures to Options Execution Module\\" is a highly modular and extensible Pine Script\u2122 template designed for advanced TradingView users, particularly those interested in automating options trading based on futures signals. Here\u2019s a concise overview of the template and how traders can build on it:","source":"@site/docs/trading-platform/tradingview/futures-to-options-module.md","sourceDirName":"trading-platform/tradingview","slug":"/trading-platform/tradingview/futures-to-options-module","permalink":"/docs/trading-platform/tradingview/futures-to-options-module","draft":false,"unlisted":false,"editUrl":"https://github.com/layrZero/layrZero.github.io/tree/main/docs/trading-platform/tradingview/futures-to-options-module.md","tags":[],"version":"current","frontMatter":{}}');var i=e(4848),l=e(8453);const s={},r="Futures to Options Module",a={},d=[{value:"Sample Template Overview",id:"sample-template-overview",level:4},{value:"Ensure Position Size is handled in the Properties Section",id:"ensure-position-size-is-handled-in-the-properties-section",level:3},{value:"Ensure Alert Message is Set",id:"ensure-alert-message-is-set",level:3},{value:"\ud83d\udca1 How Traders Can Use It",id:"-how-traders-can-use-it",level:4}];function g(n){const t={code:"code",h1:"h1",h3:"h3",h4:"h4",header:"header",li:"li",ol:"ol",p:"p",pre:"pre",strong:"strong",ul:"ul",...(0,l.R)(),...n.components};return(0,i.jsxs)(i.Fragment,{children:[(0,i.jsx)(t.header,{children:(0,i.jsx)(t.h1,{id:"futures-to-options-module",children:"Futures to Options Module"})}),"\n",(0,i.jsx)(t.p,{children:'The "Futures to Options Execution Module" is a highly modular and extensible Pine Script\u2122 template designed for advanced TradingView users, particularly those interested in automating options trading based on futures signals. Here\u2019s a concise overview of the template and how traders can build on it:'}),"\n",(0,i.jsx)("img",{src:e(4613).A}),"\n",(0,i.jsx)(t.h4,{id:"sample-template-overview",children:"Sample Template Overview"}),"\n",(0,i.jsx)(t.p,{children:"This module is structured into 8 distinct blocks, each with a specific function:"}),"\n",(0,i.jsxs)(t.ol,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"OpenAlgo API Controls"}),": Connects to OpenAlgo for live execution, allowing integration with real trading APIs."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Backtesting & Risk Controls"}),": Defines trading timeframes, and configurable risk parameters including Stoploss/Target (fixed, percentage, or ATR-based)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Trading Strategy Block"}),": Users can plug in any logic here. The default implementation includes a HalfTrend + ATR channel-based strategy."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Signal Mapping & Intraday Filtering"}),": Converts strategy conditions into buy/sell signals and handles intraday session logic."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Option Symbol Generation & API Messaging"}),": Frames CE/PE option symbols dynamically based on spot price, expiry, and strike intervals."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Trade Execution Logic"}),": Executes trades based on signal, handles square-off and mode control (Enable, Long-only, Short-only)."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"SL/TP Visualization"}),": Plots stoploss and target markers based on the selected risk model."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Trading Dashboard"}),": Displays real-time trade info (entry/exit signals) on the chart using tables."]}),"\n"]}),"\n",(0,i.jsx)(t.pre,{children:(0,i.jsx)(t.code,{className:"language-coffeescript",children:'// This Pine Script\u2122 code is subject to the terms of the Mozilla Public License 2.0 at https://mozilla.org/MPL/2.0/\n// \xa9 openalgo\n\n//Trading Block Description\n\n//Block1 : OpenAlgo API controls\n//Block2 : Backtesting Controls & Target and Stoploss Controls\n//Block3: Trading Strategy and Controls (Write your strategy Block)\n//Block4: Intraday Function and Buy and Sell Signal Mapping (Signal Mapping is Required)\n//Block5: Framing Option Symbols and API Message Structure\n//Block6: Trade Execution Controls\n//Block7: Plotting Stoploss and Target\n//Block8: Plotting Trading Dashboard\n\n//@version=6\nstrategy("Futures to Options Execution Module", overlay=true, fill_orders_on_standard_ohlc = true)\n\n//Block1 :  OpenAlgo API controls\n\n// Input controls\napikey = input.string("xxxxxxxxxxxx", title="OpenAlgo API Key", group="OpenAlgo")\nstrategyType = input.string("Tradingview", title="Strategy", group="OpenAlgo")\nUnderlying = input.symbol(title = "Underlying Symbol", defval = "NSE:NIFTY", group = "OpenAlgo")\nExpiry = input.string(title="Expiry Date",defval="30JAN25",group = "OpenAlgo")\niInterval = input.int(title=\'Strike Interval\',defval = 50, group = "OpenAlgo")\nlotsize = input.int(title = "LotSize", defval = 75,group="OpenAlgo")\nquantity = input.int(title = "Quantity(Lots)", defval = 1,group="OpenAlgo")\noffsetCE = input.int(title = "OffsetCE", defval = 0,minval=-40,maxval=40, step=1, group="OpenAlgo")\noffsetPE = input.int(title = "OffsetPE", defval = 0,minval=-40,maxval=40, step=1, group="OpenAlgo")\nexchange = input.string("NFO", title="Exchange", options=["NFO", "BFO", "MCX"], group="OpenAlgo")\nproduct = input.string("MIS", title="Product Type", options=["MIS", "NRML"], group="OpenAlgo")\nalgomode = input.string(title="Algo Mode",defval = "ENABLE",options=[\'ENABLE\',"LONGONLY","SHORTONLY"])\n\n// Hardcoded Price Type\npricetype = "MARKET"\n\n//Get the Strike Interval\nSpotC1 = request.security(Underlying,timeframe.period,close)\nSpotC = SpotC1[1]\n\n//calculate the ATM/OTM/ITM Options\nstrike = SpotC % iInterval > iInterval/2 ? SpotC - (SpotC%iInterval) + iInterval : SpotC - (SpotC%iInterval)\nstrikeCE = strike + (offsetCE * iInterval)\nstrikePE = strike - (offsetPE * iInterval)\n\n\n////////////////////////Block 1 Module Ends ///////////////////////////////////////////////////////////////////////\n\n\n//Block 2 : Backtesting Controls & Target and Stoploss Controls\n\nFromMonth = input.int(defval=9, title=\'From Month\', minval=1, maxval=12, group=\'Backtesting\')\nFromDay = input.int(defval=1, title=\'From Day\', minval=1, maxval=31, group=\'Backtesting\')\nFromYear = input.int(defval=2018, title=\'From Year\', minval=999, group=\'Backtesting\')\nToMonth = input.int(defval=1, title=\'To Month\', minval=1, maxval=12, group=\'Backtesting\')\nToDay = input.int(defval=1, title=\'To Day\', minval=1, maxval=31, group=\'Backtesting\')\nToYear = input.int(defval=9999, title=\'To Year\', minval=999, group=\'Backtesting\')\nstart = timestamp(FromYear, FromMonth, FromDay, 00, 00)\nfinish = timestamp(ToYear, ToMonth, ToDay, 23, 59)\nwindow() =>\n    time >= start and time <= finish ? true : false\n\n\n\nhighlighting = input.bool(title=\'Highlighter On/Off ?\', defval=true, group=\'Intraday Controls\')\nbarcoloring = input.bool(title=\'Bar Coloring On/Off ?\', defval=true, group=\'Intraday Controls\')\n\nintraday = input.bool(title=\'Intraday On/Off ?\', defval=false, group=\'Intraday Controls\')\nmarketSession = input.session(title=\'Market session\', defval=\'0915-1500\', confirm=false, group=\'Intraday Controls\')\n\nrisk = input.bool(title=\'Stoploss/Target On/Off\', defval=false, group=\'Stoploss/Target Controls\')\nitype = input.string(title=\'Type\', defval=\'FIXED\', options=[\'FIXED\', \'PERCENTAGE\', \'VOLATILITY\'], group=\'Stoploss/Target Controls\')\nstop = input.float(defval=10.0, title=\'Stoploss\', group=\'Stoploss/Target Controls\')\ntarget = input.float(defval=20.0, title=\'Target\', group=\'Stoploss/Target Controls\')\nTickSz = input.float(defval=0.05, title=\'TickSize\', group=\'Stoploss/Target Controls\')\nATRMultiplier = input.float(title=\'ATR Multiplier\', step=0.1, defval=1.5, group=\'Stoploss/Target Controls\')\nATRLength = input.int(title=\'ATR Period\', defval=20, group=\'Stoploss/Target Controls\')\n\niATR = ta.atr(ATRLength)\n\n////////////////////////Block 2 Module Ends ///////////////////////////////////////////////////////////////////////\n\n\n//Block 3 : Trading Strategy and Controls \n\n\namplitude = input(title = \'Amplitude\', defval = 2)\nchannelDeviation = input(title = \'Channel Deviation\', defval = 2)\n//showArrows = input(title = \'Show Arrows\', defval = true)\nshowChannels = input(title = \'Show Channels\', defval = true)\n\nvar int trend = 0\nvar int nextTrend = 0\nvar float maxLowPrice = nz(low[1], low)\nvar float minHighPrice = nz(high[1], high)\n\nvar float up = 0.0\nvar float down = 0.0\nfloat atrHigh = 0.0\nfloat atrLow = 0.0\nfloat arrowUp = na\nfloat arrowDown = na\n\natr2 = ta.atr(100) / 2\ndev = channelDeviation * atr2\n\nhighPrice = high[math.abs(ta.highestbars(amplitude))]\nlowPrice = low[math.abs(ta.lowestbars(amplitude))]\nhighma = ta.sma(high, amplitude)\nlowma = ta.sma(low, amplitude)\n\nif nextTrend == 1\n    maxLowPrice := math.max(lowPrice, maxLowPrice)\n\n    if highma < maxLowPrice and close < nz(low[1], low)\n        trend := 1\n        nextTrend := 0\n        minHighPrice := highPrice\n        minHighPrice\nelse\n    minHighPrice := math.min(highPrice, minHighPrice)\n\n    if lowma > minHighPrice and close > nz(high[1], high)\n        trend := 0\n        nextTrend := 1\n        maxLowPrice := lowPrice\n        maxLowPrice\n\nif trend == 0\n    if not na(trend[1]) and trend[1] != 0\n        up := na(down[1]) ? down : down[1]\n        arrowUp := up - atr2\n        arrowUp\n    else\n        up := na(up[1]) ? maxLowPrice : math.max(maxLowPrice, up[1])\n        up\n    atrHigh := up + dev\n    atrLow := up - dev\n    atrLow\nelse\n    if not na(trend[1]) and trend[1] != 1\n        down := na(up[1]) ? up : up[1]\n        arrowDown := down + atr2\n        arrowDown\n    else\n        down := na(down[1]) ? minHighPrice : math.min(minHighPrice, down[1])\n        down\n    atrHigh := down + dev\n    atrLow := down - dev\n    atrLow\n\nht = trend == 0 ? up : down\n\nvar color buyColor = color.blue\nvar color sellColor = color.red\n\nhtColor = trend == 0 ? buyColor : sellColor\nhtPlot = plot(ht, title = \'HalfTrend\', linewidth = 2, color = htColor)\n\natrHighPlot = plot(showChannels ? atrHigh : na, title = \'ATR High\', style = plot.style_circles, color = color.new(sellColor, 0))\natrLowPlot = plot(showChannels ? atrLow : na, title = \'ATR Low\', style = plot.style_circles, color = color.new(buyColor, 0))\n\nfill(htPlot, atrHighPlot, title = \'ATR High Ribbon\', color = color.new(sellColor, 90))\nfill(htPlot, atrLowPlot, title = \'ATR Low Ribbon\', color = color.new(buyColor, 90))\n\nlongCondition = not na(arrowUp) and trend == 0 and trend[1] == 1\nshortCondition = not na(arrowDown) and trend == 1 and trend[1] == 0\n\n////////////////////////Block 3 Module Ends ///////////////////////////////////////////////////////////////////////\n\n//Block 4 : Intraday Function and Buy and Sell Signal Mapping (Signal Mapping is Required)\n\n\n//Remove the comments to do the long/short signal mapping\n\nbuySignal = longCondition\nsellSignal = shortCondition\n\nbarInSession(sess) =>\n    time(timeframe.period, sess) != 0\n    \nbool intradaySession = barInSession(marketSession)\n\nbuy = buySignal\nsell = sellSignal\n\nbuy1 = buy[1]\nsell1 = sell[1]\n\n\n////////////////////////Block 4 Module Ends ///////////////////////////////////////////////////////////////////////\n\n//Block 5 : Framing Option Symbols and API Message Structure\n\nTSYMce= ta.valuewhen(buy,strikeCE,0)\nTSYMpe= ta.valuewhen(sell,strikePE,0)\n\nsymbolinfo = str.replace_all(Underlying,"NSE:","")\nsymbolinfo := str.replace_all(symbolinfo,"1!","")\nsymbolinfo := str.replace_all(symbolinfo,"2!","")\n\n\n//Framing a Option Symbols\ntradSYMCE=symbolinfo + Expiry + str.tostring(TSYMce)+ \'CE\'        \ntradSYMPE=symbolinfo + Expiry + str.tostring(TSYMpe)+ \'PE\'\n\n\n//initial declarations\nvar islong = false\nvar issell = false\nvar symCE = \'\'\nvar symPE = \'\'\nvar exitsymCE = \'\'\nvar exitsymPE = \'\'\nvar tpslCE = \'\'\nvar tpslPE = \'\'\n\n\nbuy := not islong and buy\nsell := not issell and sell\n\nif buy\n    islong := true //Buy signal is continuing\n    issell := false //reset the sell continue\n    symCE := symbolinfo + Expiry + str.tostring(TSYMce)+ \'CE\'\n    tpslCE := symCE\n    exitsymPE := symPE  //storing the PE symbol value for exit\n    symPE := \'\'\n\nif sell\n    islong :=false //Buy Signal is no more continuing\n    issell :=true //Sell Signal is continuing\n    symPE := symbolinfo + Expiry + str.tostring(TSYMpe)+ \'PE\'\n    tpslPE := symPE\n    exitsymCE := symCE  //storing the CE symbol value for exit\n    symCE := \'\'\n\nLongCall = \'{   "apikey":"\' + apikey + \'", "strategy":"\' + strategyType + \'", "symbol":"\' + symCE + \'", "action":"BUY", "exchange":"\' + exchange + \'", "pricetype":"MARKET", "product":"\' + product + \'", "quantity":"\' + str.tostring(quantity * lotsize) + \'" }\'\n\nExitCall = \'{   "apikey":"\' + apikey + \'", "strategy":"\' + strategyType + \'", "symbol":"\' + exitsymCE + \'", "action":"SELL", "exchange":"\' + exchange + \'", "pricetype":"MARKET", "product":"\' + product + \'", "quantity":"\' + str.tostring(quantity * lotsize) + \'" }\'\n\nSqCall = \'{   "apikey":"\' + apikey + \'", "strategy":"\' + strategyType + \'", "symbol":"\' + tpslCE + \'", "action":"SELL", "exchange":"\' + exchange + \'", "pricetype":"MARKET", "product":"\' + product + \'", "quantity":"\' + str.tostring(quantity * lotsize) + \'" }\'\n\nLongPut = \'{   "apikey":"\' + apikey + \'", "strategy":"\' + strategyType + \'", "symbol":"\' + symPE + \'", "action":"BUY", "exchange":"\' + exchange + \'", "pricetype":"MARKET", "product":"\' + product + \'", "quantity":"\' + str.tostring(quantity * lotsize) + \'" }\'\n\nExitPut = \'{   "apikey":"\' + apikey + \'", "strategy":"\' + strategyType + \'", "symbol":"\' + exitsymPE + \'", "action":"SELL", "exchange":"\' + exchange + \'", "pricetype":"MARKET", "product":"\' + product + \'", "quantity":"\' + str.tostring(quantity * lotsize) + \'" }\'\n\nSqPut = \'{   "apikey":"\' + apikey + \'", "strategy":"\' + strategyType + \'", "symbol":"\' + tpslPE + \'", "action":"SELL", "exchange":"\' + exchange + \'", "pricetype":"MARKET", "product":"\' + product + \'", "quantity":"\' + str.tostring(quantity * lotsize) + \'" }\'\n\n\n //assign trading signals\nif(not intraday)\n    buy := buy\n    sell := sell\n\nif(intraday)\n    buy := buy and intradaySession\n    sell := sell and intradaySession \n\n////////////////////////Block 5 Module Ends ///////////////////////////////////////////////////////////////////////\n\n\n//Block 6 : Trade Execution Controls\n\n\nif(algomode=="ENABLE")\n    //Buy Fresh Call Option\n    if buy and strategy.position_size == 0 and window()\n        strategy.entry(\'LONGCALL\', strategy.long, alert_message=LongCall)\n    \n    //Buy Fresh Put Option\n    if sell and strategy.position_size == 0 and window()\n        strategy.entry(\'LONGPUT\', strategy.short, alert_message=LongPut)\n    \n    \n    //Exit Old Put Option and Enter Fresh Call Option (Buy)\n    if buy and strategy.position_size < 0 and window()\n        strategy.close(\'LONGPUT\', alert_message=ExitPut)\n        strategy.entry(\'LONGCALL\', strategy.long, alert_message=LongCall)\n    \n    //Exit Old Call Option and Enter Fresh Put Option (Buy)\n    if sell and strategy.position_size > 0 and window()\n        strategy.close(\'LONGCALL\' ,alert_message=ExitCall)\n        strategy.entry(\'LONGPUT\', strategy.short, alert_message=LongPut)\n        \nif(algomode=="LONGONLY")\n    //Buy Fresh Call Option\n    if buy and strategy.position_size == 0 and window()\n        strategy.entry(\'LONGCALL\', strategy.long, alert_message=LongCall)\n    \n    if sell and strategy.position_size > 0 and window()\n        strategy.close(\'LONGCALL\' ,alert_message=ExitCall)\n        \nif(algomode=="SHORTONLY")\n    if buy and strategy.position_size < 0 and window()\n        strategy.close(\'LONGPUT\', alert_message=ExitPut)\n        \n    //Buy Fresh Put Option\n    if sell and strategy.position_size == 0 and window()\n        strategy.entry(\'LONGPUT\', strategy.short, alert_message=LongPut)\n\nif(intraday)\n    longsquareOff = not intradaySession and strategy.position_size > 0 \n    if(longsquareOff)\n        strategy.close(id=\'LONGCALL\', comment=\'Square-off\',alert_message=SqCall)\n    shortsquareOff = not intradaySession and strategy.position_size < 0 \n    if(shortsquareOff)\n        strategy.close(id=\'LONGPUT\', comment=\'Square-off\',alert_message=SqPut)\n\n\n////////////////////////Block 6 Module Ends ///////////////////////////////////////////////////////////////////////\n\n\n//Block 7 : Plot Stoploss and Target\n\n\nbuycount = ta.barssince(buySignal)\nsellcount = ta.barssince(sellSignal)\ncolor1 = buycount[1] < sellcount[1] ? color.green : buycount[1] > sellcount[1] ? color.red : na\nbarcolor(barcoloring ? color1 : na)\n\n\nlong_stop_level = ta.valuewhen(buy1, open - stop, 0)\nlong_profit_level = ta.valuewhen(buy1, open + target, 0)\nshort_stop_level = ta.valuewhen(sell1, open + stop, 0)\nshort_profit_level = ta.valuewhen(sell1, open - target, 0)\n\nif(itype=="PERCENTAGE")\n    long_stop_level := ta.valuewhen(buy1, open, 0) * (100-stop)/100\n    long_profit_level := ta.valuewhen(buy1, open, 0) * (100+target)/100\n    long_stop_level := TickSz * math.round(long_stop_level/TickSz)\n    long_profit_level := TickSz * math.round(long_profit_level/TickSz)\n    short_stop_level := ta.valuewhen(sell1, open, 0) * (100+stop)/100\n    short_profit_level := ta.valuewhen(sell1, open, 0) * (100-target)/100\n    short_stop_level := TickSz * math.round(short_stop_level/TickSz)\n    short_profit_level := TickSz * math.round(short_profit_level/TickSz)\n    \nif(itype=="VOLATILITY")\n    long_stop_level := ta.valuewhen(buy1, open - iATR*ATRMultiplier, 0)\n    long_profit_level := ta.valuewhen(buy1, open + iATR*ATRMultiplier, 0)\n    short_stop_level := ta.valuewhen(sell1, open + iATR*ATRMultiplier, 0)\n    short_profit_level := ta.valuewhen(sell1, open - iATR*ATRMultiplier, 0)\n\nif(risk)\n    if(strategy.position_size>0)\n        strategy.exit(\'CALL TP/SL\', \'LONGCALL\', stop=long_stop_level, limit=long_profit_level,alert_message=SqCall)\n    if(strategy.position_size<0)\n        strategy.exit(\'PUT TP/SL\', \'LONGPUT\', stop=short_stop_level, limit=short_profit_level,alert_message=SqPut)\n\nplot(strategy.position_size <= 0 or not risk ? na : long_stop_level, color=color.new(color.red, 0), style=plot.style_circles, linewidth=2)\nplot(strategy.position_size <= 0 or not risk ? na : long_profit_level, color=color.new(color.green, 0), style=plot.style_circles, linewidth=2)\nplot(strategy.position_size >= 0 or not risk ? na : short_stop_level, color=color.new(color.red, 0), style=plot.style_circles, linewidth=2)\nplot(strategy.position_size >= 0 or not risk ? na : short_profit_level, color=color.new(color.green, 0), style=plot.style_circles, linewidth=2)\n\n\n\n\n////////////////////////Block 7 Module Ends ///////////////////////////////////////////////////////////////////////\n\n\n//Block8: Plotting Trading Dashboard\n\nentrytext = \'\'\nexittext = \'\'\nif(islong)\n    entrytext := \'Long Call : \'+symCE\n    exittext := \'Exit Put : \'+exitsymPE\nif(issell)\n    entrytext :=  \'Exit Call : \'+exitsymCE\n    exittext := \'Long Put : \'+symPE\n//Trading Dashboard\nvar tLog = table.new(position = position.bottom_left, rows = 2, columns = 2, bgcolor = color.black, border_width=1)\ntable.cell(tLog, row = 0, column = 1, text = entrytext, text_color = color.green)\ntable.cell_set_text(tLog, row = 0, column = 1, text = entrytext)\ntable.cell(tLog, row = 1, column = 1, text = exittext, text_color = color.red)\ntable.cell_set_text(tLog, row = 1, column = 1, text = exittext )\n\n////////////////////////Block 8 Module Ends ///////////////////////////////////////////////////////////////////////\n\n'})}),"\n",(0,i.jsx)(t.h3,{id:"ensure-position-size-is-handled-in-the-properties-section",children:"Ensure Position Size is handled in the Properties Section"}),"\n",(0,i.jsx)("img",{src:e(7826).A}),"\n",(0,i.jsx)(t.h3,{id:"ensure-alert-message-is-set",children:"Ensure Alert Message is Set"}),"\n",(0,i.jsx)("img",{src:e(4915).A}),"\n",(0,i.jsx)(t.h4,{id:"-how-traders-can-use-it",children:"\ud83d\udca1 How Traders Can Use It"}),"\n",(0,i.jsxs)(t.ul,{children:["\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Plug-and-Play Strategy Development"}),": Insert your own logic into Block 3 to test strategies like Moving Average Crossovers, RSI signals, or ML-driven logic."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Backtest Ready"}),": Instantly simulate performance with adjustable historical timeframes."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Options Execution"}),": Automatically converts directional futures signals into options trades with customizable offsets."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"Risk Management"}),": Activate dynamic SL/TP configurations for robust risk control."]}),"\n",(0,i.jsxs)(t.li,{children:[(0,i.jsx)(t.strong,{children:"API Alerts"}),": Sends alert messages structured for API consumption\u2014ideal for auto-execution platforms."]}),"\n"]})]})}function p(n={}){const{wrapper:t}={...(0,l.R)(),...n.components};return t?(0,i.jsx)(t,{...n,children:(0,i.jsx)(g,{...n})}):g(n)}},4613:(n,t,e)=>{e.d(t,{A:()=>o});const o=e.p+"assets/images/image-efbe3dee158d55a50b10fad205b9fb38.png"},4915:(n,t,e)=>{e.d(t,{A:()=>o});const o=e.p+"assets/images/image (1)-86864c4e02fe6a8c81e48e822b175339.png"},7826:(n,t,e)=>{e.d(t,{A:()=>o});const o=e.p+"assets/images/image (2)-2e527d890df6319839c7d45ff6b0400c.png"},8453:(n,t,e)=>{e.d(t,{R:()=>s,x:()=>r});var o=e(6540);const i={},l=o.createContext(i);function s(n){const t=o.useContext(l);return o.useMemo(function(){return"function"==typeof n?n(t):{...t,...n}},[t,n])}function r(n){let t;return t=n.disableParentContext?"function"==typeof n.components?n.components(i):n.components||i:s(n.components),o.createElement(l.Provider,{value:t},n.children)}}}]);